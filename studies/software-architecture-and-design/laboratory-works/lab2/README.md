# Система доставки їжі

## Опис проекту

Цей проект реалізує систему доставки їжі з багаторівневою архітектурою для навчання з використанням сучасних підходів до розробки програмного забезпечення. Система дозволяє управляти стравами, створювати замовлення, додавати страви до замовлень та відстежувати їх статуси.

## Архітектурні принципи

### Багаторівнева архітектура (Multi-tier Architecture)

**UI Layer (Презентаційний рівень)**:
- `ConsoleApplication` - інтерактивний консольний інтерфейс
- Красиве ASCII меню з навігацією
- Валідація введення користувача
- Підтримка Unicode (українські символи)

**BLL Layer (Бізнес-логічний рівень)**:
- `DishService`, `OrderService` - бізнес-логіка
- DTO об'єкти для передачі даних
- Mapper класи для перетворення Entity ↔ DTO
- Обробка виключень

**DAL Layer (Рівень доступу до даних)**:
- Repository Pattern з Generic implementation
- Unit of Work Pattern для управління транзакціями
- JPA/Hibernate для ORM
- H2 Database для зберігання

## Реалізовані архітектурні шаблони

### 1. Repository Pattern
**Призначення**: Абстракція доступу до даних.

**Структура**:
- `IRepository<T>` - базовий інтерфейс
- `GenericRepository<T>` - загальна реалізація CRUD операцій
- `IDishRepository`, `IOrderRepository` - специфічні інтерфейси
- `DishRepository`, `OrderRepository` - конкретні реалізації

**Переваги**:
- Інкапсуляція логіки доступу до даних
- Легке тестування через мокування
- Централізація запитів до БД

### 2. Unit of Work Pattern
**Призначення**: Управління транзакціями та життєвим циклом об'єктів.

**Реалізація**:
```java
public interface IUnitOfWork {
    IDishRepository getDishRepository();
    IOrderRepository getOrderRepository();
    void beginTransaction();
    void commit();
    void rollback();
}
```

**Переваги**:
- Консистентність даних
- Управління транзакціями
- Централізований доступ до репозиторіїв

### 3. Data Transfer Object (DTO) Pattern
**Призначення**: Передача даних між шарами без експозиції внутрішньої структури.

**DTO класи**:
- `DishDto` - дані про страву
- `OrderDto` - дані про замовлення  
- `OrderItemDto` - дані про позицію в замовленні

**Переваги**:
- Розділення моделей даних та бізнес-об'єктів
- Контроль над тим, які дані передаються
- Незалежність шарів

### 4. Mapper Pattern
**Призначення**: Перетворення між Entity та DTO об'єктами.

**Mapper класи**:
- `DishMapper` - Entity ↔ DTO для страв
- `OrderMapper` - Entity ↔ DTO для замовлень
- `OrderItemMapper` - Entity ↔ DTO для позицій

### 5. Service Layer Pattern
**Призначення**: Інкапсуляція бізнес-логіки.

**Сервіси**:
- `IDishService` / `DishService` - операції зі стравами
- `IOrderService` / `OrderService` - операції із замовленнями

### 6. Dependency Injection (DI)
**Призначення**: Слабка зв'язаність компонентів.

**Реалізація**: Через конструктори та інтерфейси

## Модель даних

### Сутності

**Dish (Страва)**:
- `id` - унікальний ідентифікатор
- `name` - назва страви
- `description` - опис
- `price` - ціна
- `type` - тип страви (SOUP, MAIN_COURSE, SALAD, DESSERT, BEVERAGE)
- `isAvailable` - доступність
- `availableDate` - дата доступності

**Order (Замовлення)**:
- `id` - унікальний ідентифікатор
- `customerName` - ім'я клієнта
- `customerAddress` - адреса доставки
- `customerPhone` - телефон
- `orderDate` - дата замовлення
- `status` - статус (PENDING, CONFIRMED, PREPARING, READY, DELIVERED, CANCELLED)
- `totalPrice` - загальна сума
- `orderItems` - список позицій

**OrderItem (Позиція замовлення)**:
- `id` - унікальний ідентифікатор
- `order` - посилання на замовлення
- `dish` - посилання на страву
- `quantity` - кількість
- `price` - ціна позиції

### Зв'язки
- Order 1:N OrderItem (Одне замовлення - багато позицій)
- OrderItem N:1 Dish (Багато позицій - одна страва)

## Структура проекту

```
src/main/java/com/example2/
├── App.java                           # Головний клас застосування
├── ui/console/
│   └── ConsoleApplication.java        # Консольний інтерфейс
├── bll/                              # Business Logic Layer
│   ├── dto/                          # Data Transfer Objects
│   │   ├── DishDto.java
│   │   ├── OrderDto.java
│   │   └── OrderItemDto.java
│   ├── mappers/                      # Entity ↔ DTO mappers
│   │   ├── DishMapper.java
│   │   ├── OrderMapper.java
│   │   └── OrderItemMapper.java
│   ├── services/                     # Бізнес-сервіси
│   │   ├── interfaces/
│   │   │   ├── IDishService.java
│   │   │   └── IOrderService.java
│   │   └── implementations/
│   │       ├── DishService.java
│   │       └── OrderService.java
│   └── exceptions/                   # Кастомні виключення
│       ├── EntityNotFoundException.java
│       └── InvalidOperationException.java
├── dal/                              # Data Access Layer
│   ├── entities/                     # JPA сутності
│   │   ├── Dish.java
│   │   ├── Order.java
│   │   ├── OrderItem.java
│   │   ├── DishType.java (enum)
│   │   └── OrderStatus.java (enum)
│   ├── repositories/                 # Repository pattern
│   │   ├── interfaces/
│   │   │   ├── IRepository.java
│   │   │   ├── IDishRepository.java
│   │   │   └── IOrderRepository.java
│   │   └── implementations/
│   │       ├── GenericRepository.java
│   │       ├── DishRepository.java
│   │       └── OrderRepository.java
│   ├── uow/                         # Unit of Work pattern
│   │   ├── IUnitOfWork.java
│   │   └── UnitOfWork.java
│   └── config/
│       └── DatabaseConfig.java      # Конфігурація БД
└── resources/
    └── META-INF/
        └── persistence.xml           # JPA конфігурація
```

## Технологічний стек

- **Java 17** - мова програмування
- **Maven 3.8.0** - система збірки та управління залежностями
- **Hibernate 5.6.15** - ORM фреймворк
- **JPA 2.2** - Java Persistence API
- **H2 Database 2.1.214** - вбудована база даних
- **JUnit 5** - фреймворк для тестування

## Як запустити

### Компіляція і запуск:
```bash
# Компіляція проекту
mvn clean compile

# Запуск через Maven
mvn exec:java -Dexec.mainClass="com.example2.App"

# Або використовуйте готові скрипти:
.\run_app.bat       # Windows
./run_app.ps1       # PowerShell
```

### Запуск тестів:
```bash
mvn test
```

### Пакування в JAR:
```bash
mvn clean package
java -jar target/food-delivery-system-1.0-SNAPSHOT.jar
```

## Використання

### Інтерактивне меню системи:

```
+============================================================+
|                        ГОЛОВНЕ МЕНЮ                       |
+============================================================+
| 1. [+] Управління стравами                                |
| 2. [*] Управління замовленнями                            |
| 3. [?] Пошук                                              |
| 0. [X] Вихід                                              |
+============================================================+
```

### Нові функції навігації ✨

- **Можливість повернення назад** - у кожному підменю є опція "0" для повернення
- **Красивий ASCII дизайн** - структуровані та читабельні меню
- **Валідація введення** - захист від некоректного вводу
- **Підтвердження дій** - запит підтвердження для критичних операцій
- **Пауза між операціями** - "Натисніть Enter для продовження..."
- **Підтримка Unicode** - правильне відображення українських символів

### Приклад роботи:

**Створення замовлення:**
```
=== СТВОРИТИ ЗАМОВЛЕННЯ ===
Ім'я клієнта: Іван Петренко
Адреса доставки: вул. Хрещатик, 1
Телефон: +380501234567
✓ Замовлення створено з ID: 1
```

**Додавання страви до замовлення:**
```
=== ДОДАТИ СТРАВУ ДО ЗАМОВЛЕННЯ ===
ID замовлення: 1

=== ДОСТУПНІ СТРАВИ ===
[ID:1] Борщ український - Традиційний червоний борщ з м'ясом - 85.0 грн
[ID:2] Котлета по-київськи - Курячі котлети з маслом та зеленню - 120.0 грн

ID страви: 1
Кількість: 2
✓ Страву додано до замовлення
```

### Функціональні можливості:

**Управління стравами:**
- Перегляд всіх страв
- Фільтрація за типом (супи, основні страви, салати, десерти, напої)
- Фільтрація за датою доступності
- Перегляд доступних страв
- Додавання нових страв

**Управління замовленнями:**
- Створення нового замовлення
- Перегляд всіх замовлень
- Фільтрація за статусом
- Додавання страв до замовлення
- Підтвердження замовлення
- Відстежування статусу

**Пошук:**
- Пошук страв за назвою
- Пошук страв за ціновим діапазоном
- Пошук замовлень за клієнтом

## База даних

### Конфігурація
Система використовує H2 базу даних у **файловому режимі**:
- Файл БД: `./data/food_delivery.mv.db`
- Дані зберігаються між запусками
- Автоматична ініціалізація тестових даних

### Початкові дані
При першому запуску створюються тестові страви:
- 5 страв українською мовою
- 5 страв англійською мовою (для демонстрації пошуку)

### Схема БД
```sql
-- Автоматично генерується Hibernate
CREATE TABLE dishes (id BIGINT, name VARCHAR, description VARCHAR, ...);
CREATE TABLE orders (id BIGINT, customer_name VARCHAR, ...);
CREATE TABLE order_items (id BIGINT, order_id BIGINT, dish_id BIGINT, ...);
```

## Обробка помилок

### Кастомні виключення:
- `EntityNotFoundException` - сутність не знайдена
- `InvalidOperationException` - некоректна операція

### Валідація:
- Перевірка статусів замовлень
- Валідація існування сутностей
- Перевірка бізнес-правил

## Переваги архітектури

### Дотримання SOLID принципів:
- **SRP**: Кожен клас має одну відповідальність
- **OCP**: Легко розширюється новими сервісами та репозиторіями
- **LSP**: Всі реалізації можуть замінювати базові інтерфейси
- **ISP**: Інтерфейси сфокусовані на конкретних задачах
- **DIP**: Залежності від абстракцій, а не конкретних класів

### Інші принципи:
- **DRY**: Код не повторюється (Generic Repository)
- **YAGNI**: Реалізовано тільки необхідний функціонал
- **KISS**: Проста та зрозуміла архітектура
- **High Cohesion, Loose Coupling**: Високий зв'язок всередині класів, слабкий між ними

## Розширюваність

Система легко розширюється:

1. **Нові типи страв**: Додати значення до enum `DishType`
2. **Нові статуси замовлень**: Розширити enum `OrderStatus`
3. **Нові сервіси**: Створити інтерфейс та реалізацію
4. **Нові репозиторії**: Наслідувати `GenericRepository<T>`
5. **Нові DTO**: Створити DTO та відповідний Mapper
6. **Нові інтерфейси**: Web UI, REST API, Mobile API

## Тестування

### Структура тестів:
```
src/test/java/com/example2/
└── AppTest.java    # Базові тести
```

### Запуск тестів:
```bash
mvn test
mvn surefire-report:report    # Генерація звіту
```

## UML діаграми

Проект включає повний набір UML діаграм:
- **Діаграма класів** - повна архітектура системи
- **Діаграма компонентів** - зв'язки між модулями
- **Діаграми послідовності** - сценарії використання
- **Діаграма станів** - життєвий цикл замовлення
- **Діаграма пакетів** - структура проекту

Дивіться файли: `UML_DIAGRAMS.md`

## Альтернативні рішення

1. **Замість Repository Pattern**: Прямий доступ до EntityManager, але втратилася би абстракція
2. **Замість Unit of Work**: Управління транзакціями в сервісах, але збільшився би дублюючий код
3. **Замість DTO Pattern**: Прямого використання Entity, але порушилася би інкапсуляція
4. **Замість Service Layer**: MVC з товстими контролерами, але порушився би принцип єдиної відповідальності

Обрані шаблони забезпечують найкращий баланс між **гнучкістю**, **розширюваністю**, **підтримуваністю** та **тестованістю** коду.

## Автор

Проект створено для навчальних цілей як демонстрація сучасних підходів до розробки багаторівневих застосувань з використанням Java та JPA/Hibernate.
