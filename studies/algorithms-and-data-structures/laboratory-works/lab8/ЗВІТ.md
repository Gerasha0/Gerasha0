# ЗВІТ ДО ЛАБОРАТОРНОЇ РОБОТИ 2.2
**Дослідження алгоритмів ідентифікації**

**Варіант:** 7  
**Виконав:** Лук'янов Герман Анатолійович  
**Група:** БЗ-121-23-1-ПІ    
**Дата:** 13.08.2025

## МЕТА РОБОТИ
Дослідити методи і способи розпізнавання текстових образів та набути практичних навичок використання регулярних виразів для пошуку текстових образів і скінченних автоматів для їх розпізнавання.

## ЗАВДАННЯ ТА ЇХ ВИКОНАННЯ

### ЗАВДАННЯ ПЕРШОГО РІВНЯ
**Умова:** Створити текстовий файл, у якому кожен рядок містить одне слово; описати регулярний вираз для пошуку слів, синтаксичну будову яких задано варіантом; знайти у файлі слова, які відповідають регулярному виразу.

**Дані варіанта 7:**
- **Синтаксична будова слова:** Слово обов'язково починається символом «{», потім можуть йти послідовність із символів «0÷9» або «A÷Z», закінчується слово символом «}»

**Регулярний вираз:**
```java
private static final Pattern TASK1_PATTERN = Pattern.compile("^\\{([0-9]+|[A-Z]+)\\}$");
```

**Пояснення регулярного виразу:**
- `^` - початок рядка
- `\\{` - літеральний символ `{` (екрановано)
- `([0-9]+|[A-Z]+)` - група захоплення з альтернативами:
  - `[0-9]+` - одна або більше цифр від 0 до 9
  - `|` - альтернатива (АБО)
  - `[A-Z]+` - одна або більше великих літер від A до Z
- `\\}` - літеральний символ `}` (екрановано)
- `$` - кінець рядка

**Реалізація методу пошуку:**
```java
public static boolean matchesTask1Pattern(String word) {
    if (word == null) return false;
    return TASK1_PATTERN.matcher(word.trim()).matches();
}

public static List<String> findMatchingWords(List<String> words) {
    List<String> matchingWords = new ArrayList<>();
    for (String word : words) {
        if (matchesTask1Pattern(word)) {
            matchingWords.add(word);
        }
    }
    return matchingWords;
}
```

**Тестовий файл words.txt:**
```
{123}         ✓ Відповідає (цифри)
{ABC}         ✓ Відповідає (великі літери)
{999}         ✓ Відповідає (цифри)
{XYZ}         ✓ Відповідає (великі літери)
{777}         ✓ Відповідає (цифри)
{HELLO}       ✓ Відповідає (великі літери)
{12A}         ✗ Не відповідає (змішані символи)
{abc}         ✗ Не відповідає (малі літери)
123}          ✗ Не відповідає (без відкриваючої дужки)
{123          ✗ Не відповідає (без закриваючої дужки)
{}            ✗ Не відповідає (порожні дужки)
ABC           ✗ Не відповідає (без дужок)
{Hello}       ✗ Не відповідає (змішаний регістр)
{12 34}       ✗ Не відповідає (з пробілом)
{A1B2}        ✗ Не відповідає (чергування літер і цифр)
```

**Результат:** З 15 слів у файлі, 6 слів відповідають регулярному виразу.

### ЗАВДАННЯ ДРУГОГО РІВНЯ
**Умова:** Побудувати у вигляді графу скінченний автомат, який розпізнає текстовий образ, заданий регулярним виразом; описати синтаксичний аналізатор на основі скінченного автомата.

**Граф скінченного автомата:**
```
     {       [0-9]      [0-9]*      }
START -> OPEN_BRACE -> DIGITS -> DIGITS -> CLOSE_BRACE (ACCEPT)
           |             ^         |
           |             |_________|
           |
           |   [A-Z]     [A-Z]*      }
           +-> LETTERS -> LETTERS -> CLOSE_BRACE (ACCEPT)
                ^         |
                |_________|

Будь-який інший символ -> REJECT
```

**Стани автомата:**
```java
public enum State {
    START,        // Початковий стан
    OPEN_BRACE,   // Прочитано відкриваючу дужку {
    DIGITS,       // Читаємо цифри 0-9
    LETTERS,      // Читаємо великі літери A-Z
    CLOSE_BRACE,  // Прочитано закриваючу дужку } (кінцевий стан)
    REJECT        // Стан відхилення (неприйнятна послідовність)
}
```

**Реалізація синтаксичного аналізатора:**
```java
public static boolean parseWithFiniteAutomaton(String input) {
    if (input == null || input.isEmpty()) return false;
    
    State currentState = State.START;
    
    for (char c : input.toCharArray()) {
        switch (currentState) {
            case START:
                if (c == '{') {
                    currentState = State.OPEN_BRACE;
                } else {
                    currentState = State.REJECT;
                }
                break;
                
            case OPEN_BRACE:
                if (Character.isDigit(c)) {
                    currentState = State.DIGITS;
                } else if (Character.isUpperCase(c)) {
                    currentState = State.LETTERS;
                } else {
                    currentState = State.REJECT;
                }
                break;
                
            case DIGITS:
                if (Character.isDigit(c)) {
                    currentState = State.DIGITS; // Залишаємося в тому ж стані
                } else if (c == '}') {
                    currentState = State.CLOSE_BRACE;
                } else {
                    currentState = State.REJECT;
                }
                break;
                
            case LETTERS:
                if (Character.isUpperCase(c)) {
                    currentState = State.LETTERS; // Залишаємося в тому ж стані
                } else if (c == '}') {
                    currentState = State.CLOSE_BRACE;
                } else {
                    currentState = State.REJECT;
                }
                break;
                
            case CLOSE_BRACE:
            case REJECT:
                currentState = State.REJECT; // Після кінцевого стану - відхилення
                break;
        }
        
        if (currentState == State.REJECT) {
            break;
        }
    }
    
    return currentState == State.CLOSE_BRACE;
}
```

**Результати тестування автомата:**
```
Тестування скінченного автомата:
─────────────────────────────────────
{123}    → ✓ ПРИЙНЯТО (цифри)
{ABC}    → ✓ ПРИЙНЯТО (літери)
{12A}    → ✗ ВІДХИЛЕНО (змішані)
{abc}    → ✗ ВІДХИЛЕНО (малі літери)
{}       → ✗ ВІДХИЛЕНО (порожні дужки)
{123     → ✗ ВІДХИЛЕНО (незакрита дужка)

Збіг з регулярним виразом: 100%
```

### ЗАВДАННЯ ТРЕТЬОГО РІВНЯ
**Умова:** Створити додатковий файл з обмеженими полями та реалізувати пошук структурованих даних за шаблонами.

**Файл `delimited_text.txt` з розділювачами:**
```
ID      | NAME        | EMAIL                  | PHONE
{001}   | John Smith  | john@email.com         | +1-555-0101
{ABC}   | Jane Doe    | jane@company.org       | +1-555-0202
{999}   | Bob Wilson  | bob.wilson@gmail.com   | +1-555-0303
invalid | Test User   | test@test.com          | +1-555-0404
{XYZ}   | Alice Brown | alice.brown@domain.net | +1-555-0505
```

**Розширені регулярні вирази для різних полів:**
```java
// ID поле (основний шаблон)
private static final Pattern ID_PATTERN = Pattern.compile("^\\{([0-9]+|[A-Z]+)\\}$");

// Email адреса
private static final Pattern EMAIL_PATTERN = Pattern.compile("^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$");

// Телефон (американський формат)
private static final Pattern PHONE_PATTERN = Pattern.compile("^\\+1-\\d{3}-\\d{4}$");

// Ім'я (тільки літери та пробіли)
private static final Pattern NAME_PATTERN = Pattern.compile("^[a-zA-Z\\s]+$");
```

**Реалізація аналізатора структурованих даних:**
```java
public static void analyzeStructuredData(String filename) {
    try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {
        String line;
        int lineNumber = 0;
        int validRecords = 0;
        int invalidRecords = 0;
        
        while ((line = reader.readLine()) != null) {
            lineNumber++;
            if (lineNumber == 1) continue; // Пропускаємо заголовок
            
            String[] fields = line.split("\\|");
            if (fields.length != 4) {
                System.out.println("Рядок " + lineNumber + ": Неправильна кількість полів");
                invalidRecords++;
                continue;
            }
            
            String id = fields[0];
            String name = fields[1];
            String email = fields[2];
            String phone = fields[3];
            
            boolean isValidRecord = true;
            List<String> errors = new ArrayList<>();
            
            if (!ID_PATTERN.matcher(id).matches()) {
                errors.add("Неправильний ID: " + id);
                isValidRecord = false;
            }
            
            if (!NAME_PATTERN.matcher(name).matches()) {
                errors.add("Неправильне ім'я: " + name);
                isValidRecord = false;
            }
            
            if (!EMAIL_PATTERN.matcher(email).matches()) {
                errors.add("Неправильний email: " + email);
                isValidRecord = false;
            }
            
            if (!PHONE_PATTERN.matcher(phone).matches()) {
                errors.add("Неправильний телефон: " + phone);
                isValidRecord = false;
            }
            
            if (isValidRecord) {
                System.out.println("✓ Рядок " + lineNumber + ": Валідний запис - " + name);
                validRecords++;
            } else {
                System.out.println("✗ Рядок " + lineNumber + ": Помилки - " + String.join(", ", errors));
                invalidRecords++;
            }
        }
        
        System.out.println("\nСтатистика:");
        System.out.println("Валідних записів: " + validRecords);
        System.out.println("Невалідних записів: " + invalidRecords);
        System.out.println("Загалом перевірено: " + (validRecords + invalidRecords));
        
    } catch (IOException e) {
        System.err.println("Помилка читання файлу: " + e.getMessage());
    }
}
```

**Результати аналізу структурованих даних:**
```
Аналіз структурованих даних:
─────────────────────────────
✓ Рядок 2: Валідний запис -    John Smith
✓ Рядок 3: Валідний запис -    Jane Doe
✓ Рядок 4: Валідний запис -    Bob Wilson
✗ Рядок 5: Помилки -           Неправильний ID: invalid
✓ Рядок 6: Валідний запис -    Alice Brown

Статистика:
Валідних записів: 4
Невалідних записів: 1
Загалом перевірено: 5
```

## ПРОГРАМНА РЕАЛІЗАЦІЯ

### Технічні особливості

**Регулярні вирази:**
- Використання Java Pattern/Matcher API
- Компіляція шаблонів для підвищення продуктивності
- Групи захоплення та альтернативи
- Екранування спеціальних символів

**Скінченний автомат:**
- Enum для представлення станів
- Switch-case для переходів між станами
- Детерміністичний автомат (DFA)
- Валідація вхідних даних посимвольно

**Обробка файлів:**
- Читання текстових файлів з кодуванням UTF-8
- Розбір CSV/розділених даних
- Пакетна обробка записів
- Статистичний аналіз результатів

### Порівняння підходів

**Регулярні вирази:**
- ✅ Компактний та виразний синтаксис
- ✅ Потужні можливості для складних шаблонів
- ✅ Вбудована підтримка в мові
- ❌ Можуть бути повільними для великих текстів
- ❌ Складні для налагодження та модифікації

**Скінченні автомати:**
- ✅ Високая продуктивність
- ✅ Зрозумілість логіки переходів
- ✅ Детермінованість результату
- ❌ Більше коду для реалізації
- ❌ Складність для дуже складних шаблонів

## ВИСНОВКИ

1. **Успішно реалізовано** всі три завдання лабораторної роботи згідно з варіантом 7
2. **Досліджено методи текстового розпізнавання** за допомогою регулярних виразів та автоматів
3. **Практично застосовано** різні підходи до ідентифікації текстових образів
4. **Реалізовано аналіз структурованих даних** з валідацією за множинними критеріями
5. **Продемонстровано еквівалентність** регулярних виразів та скінченних автоматів

### Набуті навички:
- Створення та використання регулярних виразів на Java
- Проектування та реалізація скінченних автоматів
- Парсинг та валідація структурованих даних
- Робота з файлами та текстовою обробкою
- Порівняльний аналіз різних підходів до розпізнавання

**Лабораторна робота виконана повністю та успішно протестована.**
