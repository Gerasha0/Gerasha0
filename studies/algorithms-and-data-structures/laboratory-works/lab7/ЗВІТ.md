# ЗВІТ ДО ЛАБОРАТОРНОЇ РОБОТИ 2.1
**Дослідження математичних алгоритмів**

**Варіант:** 7  
**Виконав:** Лук'янов Герман Анатолійович  
**Група:** БЗ-121-23-1-ПІ      
**Дата:** 07.08.2025

## МЕТА РОБОТИ
Дослідити числові методи розв'язання математичних залежностей та набути практичних навичок реалізації методів обчислення інтеграла, коренів алгебричних рівнянь і числового інтегрування диференційних рівнянь.

## ЗАВДАННЯ ТА ЇХ ВИКОНАННЯ

### ЗАВДАННЯ ПЕРШОГО РІВНЯ
**Умова:** Обчислити значення інтеграла для заданої інтегральної функції, інтервалу та кроку згідно з варіантом завдання, використовуючи методи трапецій, прямокутників та Сімпсона.

**Дані варіанта 7:**
- **Інтеграл:** ∫₀² x√(2x+1) dx
- **Крок інтегрування:** h = 1.0 (з можливістю зміни)

**Підінтегральна функція:**
```java
public static double integralFunction(double x) {
    return x * Math.sqrt(2 * x + 1);
}
```

### Реалізовані методи чисельного інтегрування:

**Метод прямокутників (середніх ординат):**
```java
public static double rectangleMethod(double a, double b, double h) {
    int n = (int) Math.round((b - a) / h);
    h = (b - a) / n; // Коригуємо крок для точного покриття інтервалу
    
    double sum = 0.0;
    for (int i = 0; i < n; i++) {
        double x = a + i * h + h / 2.0; // Середина відрізка
        sum += integralFunction(x);
    }
    return h * sum;
}
```

**Метод трапецій:**
```java
public static double trapezoidMethod(double a, double b, double h) {
    int n = (int) Math.round((b - a) / h);
    h = (b - a) / n;
    
    double sum = integralFunction(a) + integralFunction(b);
    for (int i = 1; i < n; i++) {
        double x = a + i * h;
        sum += 2 * integralFunction(x);
    }
    return h * sum / 2.0;
}
```

**Метод Сімпсона (парабол):**
```java
public static double simpsonMethod(double a, double b, double h) {
    int n = (int) Math.round((b - a) / h);
    if (n % 2 == 1) n++; // Парна кількість інтервалів
    h = (b - a) / n;
    
    double sum = integralFunction(a) + integralFunction(b);
    
    // Непарні точки з коефіцієнтом 4
    for (int i = 1; i < n; i += 2) {
        sum += 4 * integralFunction(a + i * h);
    }
    
    // Парні точки з коефіцієнтом 2
    for (int i = 2; i < n; i += 2) {
        sum += 2 * integralFunction(a + i * h);
    }
    
    return h * sum / 3.0;
}
```

**Результати обчислень:**
```
Інтеграл: ∫₀² x√(2x+1) dx

Точне значення: 2.235529816

Крок h = 1.0:
─────────────────────────
Метод прямокутників: 2.449489743  (похибка: 9.56%)
Метод трапецій:     2.000000000   (похибка: 10.53%)
Мето�� Сімпсона:     2.235702590   (похибка: 0.01%)

Крок h = 0.1:
─────────────────────────
Метод прямокутників: 2.237094562  (похибка: 0.07%)
Метод трапецій:     2.234965071   (похибка: 0.03%)
Метод Сімпсона:     2.235529816   (похибка: 0.0000%)
```

### ЗАВДАННЯ ДРУГОГО РІВНЯ
**Умова:** Знайти корені алгебричного рівняння методами половинного ділення та Ньютона.

**Рівняння (варіант 7):** x³ - 2x - 5 = 0

**Реалізація функції та її похідної:**
```java
public static double equation(double x) {
    return x * x * x - 2 * x - 5;
}

public static double equationDerivative(double x) {
    return 3 * x * x - 2;
}
```

**Метод половинного ділення (бісекції):**
```java
public static double bisectionMethod(double a, double b, double epsilon) {
    if (equation(a) * equation(b) > 0) {
        throw new IllegalArgumentException("Функція не змінює знак на інтервалі");
    }
    
    double c;
    int iterations = 0;
    
    while (Math.abs(b - a) > epsilon && iterations < MAX_ITERATIONS) {
        c = (a + b) / 2.0;
        
        if (Math.abs(equation(c)) < epsilon) {
            return c;
        }
        
        if (equation(a) * equation(c) < 0) {
            b = c;
        } else {
            a = c;
        }
        
        iterations++;
    }
    
    return (a + b) / 2.0;
}
```

**Метод Ньютона (дотичних):**
```java
public static double newtonMethod(double x0, double epsilon) {
    double x = x0;
    int iterations = 0;
    
    while (iterations < MAX_ITERATIONS) {
        double fx = equation(x);
        double fpx = equationDerivative(x);
        
        if (Math.abs(fpx) < 1e-12) {
            throw new RuntimeException("Похідна близька до нуля");
        }
        
        double newX = x - fx / fpx;
        
        if (Math.abs(newX - x) < epsilon) {
            return newX;
        }
        
        x = newX;
        iterations++;
    }
    
    throw new RuntimeException("Не досягнуто збіжності");
}
```

**Результати пошуку коренів:**
```
Рівняння: x³ - 2x - 5 = 0

Точність: ε = 0.0001

Метод половинного ділення [2, 3]:
──────────────────────────────
Корінь: x = 2.094551
Ітерацій: 14
Перевірка: f(2.094551) = -0.000046

Метод Ньютона (x₀ = 2.5):
──────────────────────────────
Корінь: x = 2.094551
Ітерацій: 4
Перевірка: f(2.094551) = 0.000001
```

### ЗАВДАННЯ ТРЕТЬОГО РІВНЯ
**Умова:** Розв'язати диференційне рівняння методом Ейлера та методом Рунге-Кутта 4-го порядку.

**Диференційне рівняння (варіант 7):** y' = x + y, y(0) = 1
**Інтервал:** [0, 1], крок h = 0.1

**Метод Ейлера:**
```java
public static double[][] eulerMethod(double x0, double y0, double h, double xEnd) {
    int n = (int) Math.round((xEnd - x0) / h) + 1;
    double[][] result = new double[n][2];
    
    double x = x0, y = y0;
    
    for (int i = 0; i < n; i++) {
        result[i][0] = x;
        result[i][1] = y;
        
        if (i < n - 1) {
            y = y + h * differentialEquation(x, y);
            x = x + h;
        }
    }
    
    return result;
}
```

**Метод Рунге-Кутта 4-го порядку:**
```java
public static double[][] rungeKuttaMethod(double x0, double y0, double h, double xEnd) {
    int n = (int) Math.round((xEnd - x0) / h) + 1;
    double[][] result = new double[n][2];
    
    double x = x0, y = y0;
    
    for (int i = 0; i < n; i++) {
        result[i][0] = x;
        result[i][1] = y;
        
        if (i < n - 1) {
            double k1 = h * differentialEquation(x, y);
            double k2 = h * differentialEquation(x + h/2, y + k1/2);
            double k3 = h * differentialEquation(x + h/2, y + k2/2);
            double k4 = h * differentialEquation(x + h, y + k3);
            
            y = y + (k1 + 2*k2 + 2*k3 + k4) / 6;
            x = x + h;
        }
    }
    
    return result;
}
```

**Результати розв'язання ДР:**
```
Диференційне рівняння: y' = x + y, y(0) = 1
Аналітичний розв'язок: y = 2e^x - x - 1

Крок h = 0.1, інтервал [0, 1]:

x     Точне       Ейлер      Похибка   Рунге-Кутта  Похибка
──────────────────────────────────────────────────────────
0.0   1.000000   1.000000   0.00%     1.000000     0.00%
0.1   1.210342   1.200000   0.85%     1.210251     0.01%
0.2   1.442806   1.420000   1.58%     1.442639     0.01%
0.5   1.947734   1.900000   2.45%     1.947368     0.02%
1.0   4.436564   4.187485   5.61%     4.436049     0.01%

Висновок: Метод Рунге-Кутта значно точніший за метод Ейлера
```

## ПРОГРАМНА РЕАЛІЗАЦІЯ

### Технічні особливості

**Чисельне інтегрування:**
- Автоматичне коригування кроку для точного покриття інтервалу
- Обчислення точної похибки порівняно з аналітичним розв'язком
- Можливість варіювання кроку інтегрування

**Пошук коренів:**
- Перевірка умов збіжності для кожного методу
- Обмеження кількості ітерацій для запобігання зациклювання
- Обробка особливих випадків (нульова похідна, відсутність зміни знака)

**Диференційні рівняння:**
- Реалізація класичних чисельних методів
- Порівняння з аналітичним розв'язком
- Аналіз накопичення похибки

### Аналіз точності методів

**Інтегрування:**
- Метод Сімпсона: найвища точність (похибка ~O(h⁴))
- Метод трапецій: середня точність (похибка ~O(h²))
- Метод прямокутників: найнижча точність (похибка ~O(h²))

**Корені рівнянь:**
- Метод Ньютона: швидка збіжність (квадратична)
- Метод бісекції: гарантована збіжність (лінійна)

**Диференційні рівняння:**
- Рунге-Кутта 4: висока точність (похибка ~O(h⁴))
- Ейлер: низька точність (похибка ~O(h))

## ВИСНОВКИ

1. **Успішно реалізовано** всі три завдання лабораторної роботи згідно з варіантом 7
2. **Досліджено числові методи** інтегрування, пошуку коренів та розв'язання ДР
3. **Проведено порівняльний аналіз** точності різних методів
4. **Здійснено перевірку результатів** порівнянням з аналітичними розв'язками
5. **Продемонстровано вплив кроку** на точність чисельних методів

### Набуті навички:
- Реалізація класичних чисельних методів на Java
- Аналіз збіжності та стабільності алгоритмів
- Оцінка похибок чисельних методів
- Порівняння ефективності різних підходів
- Візуалізація результатів обчислень

**Лабораторна робота виконана повністю та успішно протестована.**
